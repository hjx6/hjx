
# 1.团队协作
- 1.1 企共的开发环境只有四个环境,本地开发(development),测试环境(testing),灰度环境(stage),线上环境(prodution)
- 1.2 第一步: 配置邮箱和用户名,生成秘钥(ssh)
- 1.3 第二步:将线上仓库关联至本地,使用git clone xxx命令
- 1.4 第三步: 从master新建分支,新建自己的开发分支,切换至master分支,使用git checkout -b分支名(自己的名字需求名称,新建并切换自己的分支)
- 1.5 第四步: 开发需求,并上传至自己的分支
- 1.6 第五步: 自测通过后,将自己的分支合并至development分支,发布上线
- 1.7 第六步: 切换测试分支,将自己的分支合并至testing分支,发布,让测试人员测试,测试人员测试通过后,
- 1.8 第七步: 切换灰度分支,将自己的分支合并至stage分支,发布,进入灰度测试
- 1.9 第八步:上线,prodution,有两种情况: 第一种切换至production分支,进行合并,第二种就是打包: 上传至服务器




 # 2. 改变this指向的方法
### 重点:箭头函数,不能改变this指向,只有普通function函数,能改变this指向
#### 2.1, call()方法
语法: 函数.call(参数1,其他参数....可以是多个或者没有 )
作用: 调用并且执行函数,同时,将函数的this指向,定义为指定的内容(参数1)
        参数1,是改变的this的指向
        其他参数,是原始函数的实参,原始函数有几个形参,此时就要对应的输入几个实参,没有形参,就没有实参

#### 2.2, apply()方法
语法: 函数.apply(参数1,参数2)  只有两个参数
        参数1:改变的this的指向内容
        参数2:原始函数的实参,必须是一个数组的形式,将实参定义成数组的单元
其他用法和作用于 .call是相同的

 ### 总结: call方法与apply方法,作用,效果,都是完全一致的
        只是对于原始函数的参数赋值方法不同,call方法是通过其他多个参数来实现,apply方法是通过一个数组参数来实现,两个方法没有本质的区别,爱用哪个用那个 

#### 2.3, bind()方法
语法: const 变量 = 函数.bind(参数1);
不是立即执行函数（下一篇博客有介绍 立即执行函数）
生成一个新的函数,这个新的函数是改变this指向之后的新的函数
参数1,定义的要改变的的this指向
其他参数,一般不定义,是使用函数原有的形参

### 总结:
    call apply 都是立即执行函数,参数1都是改变的this指向,其他参数是原始函数的形参(可以有,也可以没有)
    bind 不是立即执行函数,是生成一个新的函数,参数1是改变的this指向,就使用原始函数的形参



# 3. 构造函数,原型,原型链,继承

#### 3.1 构造函数
    构造函数,就是使用function关键字,自定义的函数,用来初始化对象的属性和方法
    构造函数,首字母大写
    构造函数,一般用来初始化对象的属性和方法

#### 3.2 原型
    构造函数,都有一个属性,叫做prototype,这个属性是一个对象,我们把这个对象叫做原型对象
    原型对象,默认有一个属性constructor,这个属性指向构造函数
#### 3.3 原型链
    原型链,就是原型对象,有一个属性,叫做__proto__,这个属性指向了,构造函数的原型对象

#### 3.4 继承
    继承,就是使用原型链,将一个构造函数的原型对象,赋值给另一个构造函数的原型对象


# 伪数组 Arguments
伪数组（pseudo-array）是指具有类似数组特性的对象，但不是真正的数组。JavaScript中的arguments就是一个典型的伪数组。arguments对象是在函数内部自动创建的特殊对象，用于存储函数被调用时传入的所有实参（即形参对应的实际值）。arguments对象中包含一个类数组的结构，存储了这些实参，并且可以通过下标访问它们

### 需要注意的是，伪数组是永久存在的，而通过转换得到的真正数组是临时的，只在转换后的代码段中有效。因此，在使用伪数组时，我们需要根据具体情况选择适当的处理方式。

# 4. 作用域
#### 4.1 作用域
    作用域,就是变量(包括函数)可以起作用的范围
    全局作用域,就是变量(包括函数)可以起作用的范围,全局作用域,在代码中,任何地方都可以访问到
    局部作用域,就是变量(包括函数)可以起作用的范围,局部作用域,在代码中,只有在局部作用域中才能访问到

#### 4.2 作用域链
    作用域链,就是多个作用域,组合在一起,形成一个作用域的范围,这个范围,我们叫做作用域链
#### 4.3 作用域链的查找原则
    在代码执行过程中,如果需要访问一个变量,会首先在当前作用域中查找,如果找不到,就会向上一级作用域中查找,直到找到为止,如果还没有找到,就会报错


 # 5.let、const、var的区别

### 5.1 变量提升
##### var声明的变量存在变量提升，即变量可以在声明之前调用，值为undefined
##### let和const不存在变量提升，即它们所声明的变量一定要在声明后使用，否则报错 因此在声明之前访问它们会导致暂时性死区（Temporal Dead Zone，TDZ）

### 5.2 块级作用域
##### var不存在块级作用域,使用 var 声明的变量具有函数作用域，意味着它们在函数内可见，但在块级内并不会创建新的作用域
##### let和const存在块级作用域,这意味着它们只在声明它们的块或语句内可见，而在块之外不可访问,块级作用域对于避免变量污染和提高代码的可维护性非常重要。let 和 const 的块级作用域通常更容易预测和管理 

### 5.3 重复声明
##### var允许重复声明变量
##### let和const在同一作用域不允许重复声明变量

### 5.4 修改声明的变量
##### var声明的变量可以被修改
##### let和const声明的变量不能被修改
##### const声明一个只读的常量。一旦声明，常量的值就不能改变，但对于对象和数据这种引用类型，内存地址不能修改，可以修改里面的值
### 5.5 全局变量
##### var声明的变量是全局变量,可以在代码的任何地方访问到
##### let和const声明的变量不是全局变量,不能在代码的任何地方访问到


