# ...args 剩余参数和 arguments 对象的区别

### 1.arguments

在 JavaScript 中 arguments 实际上它是当前函数的一个内置对象，所以的函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有传递过来的实参

### 2. ...args 剩余参数

在 ES6 中引入了剩余参数，形式为...变量名。

### 区别

- 1. 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
- 2. arguments 对象不是一个真正的数组，而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop。
- 3. arguments 对象还有一些附加的属性 （如 callee 属性）。

# 3.箭头函数

箭头函数是 ES6 新增的语法，用来定义匿名函数。箭头函数不能使用关键字 arguments 来访问，只能通过定义的命名参数来访问

### 箭头函数和普通函数（function）的区别

- 箭头函数没有自己的 this，arguments，super 或 new.target。这些值都从父级作用域中获取。
- 箭头函数没有原型属性。
- 箭头函数不能被 new 调用。
- 箭头函数没有自己的 arguments 对象。
- 箭头函数没有自己的 this，所以不能使用 call()，apply()，bind()这些方法去改变 this 的指向。
- 箭头函数没有自己的 prototype 对象。

### 箭头函数的 this 指向

箭头函数的 this 指向在函数定义的时候继承自外层第一个普通函数的 this 绑定（不是箭头函数）。

### 箭头函数的注意事项

- 箭头函数不绑定 arguments，取而代之用 rest 参数...解决。
- 箭头函数不能用作 Generator 函数，不能使用 yeild 关键字。
- 箭头函数没有自己的 this，所以不能使用 call()，apply()，bind()这些方法去改变 this 的指向。
- 箭头函数没有自己的 prototype，所以不能使用 new 关键字生成实例，使用 new 调用箭头函数会报错。
- 箭头函数的 this 指向是可变的，但是在箭头函数中，这种可变性是透明的。

### 函数默认值

在 ES6 中，我们可以为函数的参数设置默认值，这样在调用函数的时候如果不传入该参数，则使用默认值。
默认参数值的位置一定为尾参数，即参数定义的尾部。如果调用函数时未提供参数或者参数为 undefined，那么将会使用默认值。默认参数使得函数定义更加简洁，并且可以减少一些条件判断的需要

### 默认参数的优势

- 1. 简化函数调用：默认参数允许在函数定义中指定默认值，这样在调用函数时就不需要为每个参数都提供值，从而简化了函数调用的过程。
- 2. 提高代码可读性：通过在函数定义中设置默认参数，可以使函数的预期行为更加明确。调用函数时，无需查看函数的文档或者代码，就可以直观地了解到函数的默认行为。
- 3. 避免参数为 undefined 的情况：默认参数可以确保即使调用函数时未传递参数，函数也能正常工作。它避免了函数在处理参数为 undefined 时可能导致的错误或异常情况。
- 4. 减少条件判断：在函数内部不需要手动检查参数是否为 undefined，因为默认参数已经为函数提供了一个合理的默认值，从而减少了冗余的条件判断代码。
     灵活性：虽然函数定义了默认参数，但调用函数时仍然可以传递其他值覆盖默认值，这使得函数在不同的调用场景下具有灵活性。

### 函数的 length 属性

函数的 length 属性表示函数的预期参数个数。

# 4.解构赋值的概念和作用

#### 1.解构赋值是 ES6 引入的一项重要特性，它可以使得从数组或对象中提取数据变得更加简洁、灵活。

     通过解构赋值，可以轻松地从数组或对象中提取所需的数据，并赋值给对应的变量，而无需显式地逐个取出元素或属性。
     这种语法上的简洁性使得代码更易读、更易写，同时也减少了不必要的中间变量，提高了代码的可维护性。

#### 2.解构赋值允许我们以更直观的方式获取数组和对象中的元素或属性，同时也提供了默认值和嵌套结构的支持。

      在处理复杂数据结构时，解构赋值可以帮助我们快速地提取所需数据，避免了繁琐的手动操作，提高了代码的可读性和开发效率。
      默认值和嵌套结构的支持使得解构赋值更加灵活，能够应对各种复杂的数据情况，使得代码更具通用性和健壮性。

**_总结: 在现代 JavaScript 编程中，数组解构赋值是一项强大而灵活的特性，它能够让我们轻松地从数组中提取元素并将其赋值给变量。通过这种方式，我们可以更加便捷地处理数组中的数据，使代码变得更加清晰和易于理解。_**

### 数组解构赋值

      数组解构赋值是 ES6 引入的一项语法特性，用于从数组中提取元素并将其赋值给变量。这种语法使用方括号 [] 来指定要提取的元素，然后将元素的值赋给对应的变量。

**_更进一步的用法 ：可以忽略某些参数或使用剩余参数_**

### 对象解构赋值

      对象解构赋值是 ES6 引入的一项语法特性，用于从对象中提取属性并将其赋值给变量。这种语法使用花括号 {} 来指定要提取的属性，然后将属性的值赋给对应的变量。

**_更进一步的用法：可以设置默认值或重命名（使用新的变量名）_**

### 函数参数的解构赋值

     对象解构赋值可以直接用在函数的参数中，以便从传入的对象参数中提取所需的属性值并将其赋值给变量

##### 为何使用函数参数中的解构赋值？

    使用对象解构赋值或数组解构赋值作为函数参数的好处在于可以直接从传入的参数中提取所需的数据，使得函数的参数处理变得更加简洁和直观。同时，这样的写法也能够减少不必要的中间变量，使代码更加清晰易懂

# 5.扩展运算符的作用及使用场景

    在 JavaScript 中，扩展运算符是一种语法，使用三个连续的点（...）来展开可迭代对象（例如数组、字符串或类数组对象）或对象字面量

### 使用场景

##### 1.数组展开 ：扩展运算符可以将一个数组展开为多个独立的值。这在需要将一个数组的元素插入到另一个数组或函数参数列表中时非常有用
##### 2.函数参数的剩余：扩展运算符还可以用于函数参数的剩余（rest）参数中，允许将剩余的参数作为数组收集起来
##### 3.对象字面量扩展：扩展运算符可以在对象字面量中使用，以将一个对象的属性和方法展开到另一个对象中
##### 4.字符串展开：扩展运算符可以将一个字符串展开为单个字符的数组
##### 5.浅拷贝和合并对象：扩展运算符可以用于浅拷贝对象或合并多个对象
##### 6.数组去重：扩展运算符可以用于快速去重一个数组
      如： const numbers = [1, 2, 2, 3, 3, 4, 5, 5];
      const uniqueNumbers = [...new Set(numbers)];
      console.log(uniqueNumbers); // [1, 2, 3, 4, 5]

##### 7.与解构赋值结合使用：扩展运算符可以与解构赋值语法结合使用，方便地提取数组和对象的值

### 总结

     扩展运算符在许多情况下提供了简洁、灵活和强大的功能，可用于数组操作、对象操作、函数参数处理等。它允许我们快速处理和操作数据，提高代码的可读性和可维护性

# 6.遍历器

遍历器对象本质上，就是一个指针对象（联想遍历各种结构的指针）。
## 概念
     JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。
     遍历器 Iterator就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作(即依次处理该数据结构的所有成员)
 ### Iterator 的遍历过程是这样的
       （1）创建一个指针对象，指向当前数据结构的起始位置。，
       （2）第一次调用指针对象的 next 方法，可以将指针指向数据结构的第一个成员。
       （3）第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员。
       （4）不断调用指针对象的 next 方法，直到它指向数据结构的结束位置。

### Iterator 的作用有三个：

    一是为各种数据结构，提供一个统一的、简便的访问接口；
    二是使得数据结构的成员能够按某种次序排列；
    三是 ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费。
# 7.生成器
**1.与普通函数语法的差别，在function关键字和函数名直接有个✳号，这个*作为生成器函数的主要标识符**
**2.生成器函数在执行过程中，可以暂停，后面又能从暂停处继续执行**
**3.生成器函数中，有一个特殊的新关键字：yield——用来标注暂停点**
**4.生成器不但能对外输出数据，同时我们也可以向生成器内部传递数据**
**5.生成器函数执行完毕，指针会自动指向数据结构的结束位置，再次执行next方法，返回的结果是{value: undefined, done: true}**
**6.向生成器传递数据，首行的next方法是启动生成器，即使向其传值，也不能进行变量赋值，无论你传递什么都是徒劳的，因为传递数据只能向上个暂停点进行传递，首个暂停点不存在上个暂停点。**
**7.生成器函数的返回值，就是return语句后面的表达式的值，如果没有return语句，则返回undefined**

### 什么是生成器
    生成器是ES6新增的一种函数控制，使用的方案。它可以让我们更加灵活的控制函数什么时候继续执行，暂停执行等。
    生成器函数也是一个函数，但是和普通函数有一些区别：
    生成器函数需要在function的后面加上一个符号 *
    生成器函数可以通过yield关键字来控制函数的执行流程。
    生成器函数的返回值是一个Generator（生成器）。生成器实际上是一种特殊的迭代器。

### next方法要求
    一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象：
    done（boolean类型）：如果迭代器可以产生序列中的下一个值，则为false（等价于没有指定done的这个属性）。
    如果迭代器已将序列迭代完毕，则为true。这种情况下，value是可选的，如果value依然存在，即为迭代结束之后的默认返回值。
    value：迭代器返回的任何JavaScript代码，done为true时可以省略。
### 生成器函数
    生成器函数是ES6提供的一种异步编程解决方案。
### 生成器函数传递参数
    既然生成器可以暂停来分段执行，我们可以给每个分段来传递参数。
    我们在调用next函数时，可以给next函数传递参数，那么这个参数会作为上一个yield语句的返回值。
    一般情况下，不会给第一个next传递参数，因为第一个next前面没有yield 
### 提前结束生成器函数-return函数
    return函数也可以给生成器函数传递参数。不过执行return函数后，生成器函数就会结束，之后调用next也不会继续生成值了。当调用return时，value为return传入的参数
### 生成器抛出异常-throw函数
     除了可以给生成器函数内部传递参数之外，也可以该生成器行内部抛出异常。
     抛出异常后，可以在生成器函数中捕获异常。
### 生成器替代迭代器
     生成器是一种特殊的迭代器，在某些情况下可以使用生成器替代迭代器       

